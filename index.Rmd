---
title: "Estimation growth parameters and natural mortality rates for wedge clam (*Donax trunculus*) regarding conservation figures in Cádiz GUlf, Spain"
subtitle: ""
author: "Mardones, M; Delgado, M"
date:  "`r format(Sys.time(), '%d %B, %Y')`"
bibliography: Param_donax.bib
csl: apa.csl
link-citations: yes
linkcolor: blue
output:
  bookdown::html_document2:
    fig-caption: yes
    keep_md: true
    toc: true
    toc_deep: 3
    toc_float:
      collapsed: false
      smooth_scroll: false
    theme: cosmo
    fontsize: 0.9em
    linestretch: 1.7
    html-math-method: katex
    self-contained: true
    code-tools: true
editor_options: 
  markdown: 
    wrap: 72
---


```{r echo=FALSE, setup1}
rm(list = ls())
knitr::opts_chunk$set(echo = TRUE,
                      message = FALSE,
                      warning = FALSE,
                      fig.align = 'center',
                      dev = 'jpeg',
                      dpi = 300, 
                      fig.align='center')
#XQuartz is a mess, put this in your onload to default to cairo instead
options(bitmapType = "cairo") 
# (https://github.com/tidyverse/ggplot2/issues/2655)
# Lo mapas se hacen mas rapido
# if you need tranbslate into to raw code, run;
# knitr::purl("index.Rmd", documentation = 2)
```


# Contexto



El siguiente documento tienen como objetivo identificar y estandarizar las bases de datos provenientes del proyecto FEMP_AND_04, y a su vez generar templates para realizar una evaluación de stock de la coquina (*Donax trunculus*) en el Golfo de Cádiz en un contexto histórico. El foco se centra en proveer los insumos necesarios para realizar una evaluación de stock, la cual dependerá de las características del recurso y de la disponibilidad de información recabada en este trabajo.

Las principales piezas de información necesarias para una evaluación de stock comprenden variadas dimensiones, entre las cuales se cuentan aspectos biológicos, pesqueros y ambientales. Estos datos se encuentran disponibles en fuentes oficiales pesqueras y tambien en proyectos que comienzan a levantar información del recurso de forma sistemática desde el año 2013 bajo proyectos de financiamiento Europeo [@Delgado2015].

Una vez identificadas las bases de datos, se procede a un trabajo de estandarización y Análisis Exploratorio de Datos (AED), El AED es un componente metodológico complementario que tiene dos objetivos específicos; el primero tiene que ver con la asesoría científica para el levantamiento de indicadores biológico-pesquero, y en segundo lugar, identificar patrones y generar templates para realizar la primera evaluación de stock sobre este recurso. Estos análisis son escenciales para brindar asesoramiento a la Junta de Andalucía a través del plan de gestión para *D. trunculus* [@BOJA2023].



# Área de Estudio

Previo a modelar la dinámica poblacional de coquina, es necesario el desarrollo de un modelo conceptual adecuado sobre el cual pronunciarse sobre asesoría y estado de explotación. En este sentido, identificar dominio espacial de busqueda de información y evaluación del recurso es fundamental. La zona de distribución de la coquina objeto de este análisis es en base
a la aplicación de la regulación marisquera española, relacionado con la
producción. Para ello, el litoral andaluz se dividió en diferentes
**zonas de producción** (ZZPP) las cuales se encuentran definidas en la
Orden de 15 de julio de 1993 (BOJA nº 85 de 5/8/1993).

En esta Orden se declaran las zonas de producción y protección o mejora
de moluscos bivalvos, moluscos gasterópodos, tunicados y equinodermos
marinos de la Comunidad Autónoma de Andalucía, fuera de las cuales
quedará prohibida la su recolección. Esta norma delimita zonas de
producción de moluscos bivalvos a lo largo del litoral andaluz en los
cuales se encuentran los puntos de muestreo establecidos en el
seguimiento temporal de *D. trunculus* en el litoral de Huelva llevado a
cabo por el IEO [@Marco2022] (Figura \@ref(fig:map1)).

```{r map1, echo=FALSE, out.width="60%", fig.cap= "Mapa con los puntos de muestreo establecidos en el seguimiento temporal de D. trunculus en el litoral de Huelva llevado a cabo por el IEO."}
knitr::include_graphics("Fig/Map1.jpg") 
```

# Fuentes de Información

En este trabajo se deben revisar todos los componentes que se tienen en cuenta, para ello, investigadores del IEO prepararon una descripción de cada fuente, características y su escala temporal. La mayoría de estos datos son compuestos por el monitoreo y seguimiento científico de *Donax trunculus* en el Golfo de Cádiz, que lleva a cabo el IEO y AGAPA.

A coninuación se describen los principales componentes de información de la coquina en el Golfo de Cádiz y su escala espacial y temporal:



| Item | Periodo | Observación | Agregación  |
|:-------:|:------:|:-----------:|:---------:|
| DESEMBARQUE | 2013-2022 | kg/mariscador o barco/mes | Por playa |
| ESTRUCTURA TALLAS | 2017-2023 | Datos previos al 2020 deben ser revisados | Por playa, por tipo de rastro | DENSIDAD | 2017-2023 | g/m2/  | Mes, Playa, Rastro |
| RENDIMIENTO (CPUE) | 2013-2023 | hora/mariscador/dia. (60 min*peso coquina>25mm*5min) | Por Mes, playa, rastro |
| INDICE RECLUTAMIENTO (D15) | 2013-2022 | ind/m2 < 15mm | Por Mes, playa, rastro |
| TALLA PRIMERA MADUREZ |  | L50=10.8mm | L95= pendiente |

A continuación se describen los componentes de cada pieza de información disponible para el recurso coquina.

## Monitoreo pesquero y poblacional

Una de las fuentes de información mas importantes recopiladas y analizadas aquí, tiene relación con el proyecto FEMP-04. Este proyecto, a través de muestreos en playa mensuales, recopila data de diversos indicadores de la población, así como también de la pesquería. Cabe señalar que estos datos han sido sistematicaticamente recopiladas desde el año 2013, sin embargo, tienen complejidades que deben ser atendidas previo a cualquer tratamiento de datos. Los datos han sido colectados con periocidad mensual, pero estos han sufrido cambios de formato importantes los cuales tienen implicancias al momento de la estandarización. Lo primero es entender que los muestreos, ya sea `POBLACIONAL`y `COMERCIAL`, tienen una serie de calculos sucesivos posteriores a los registros crudos. En ese sentido, los siguientes diagramas muestran la lógica utilizada para calcular las variables en el muestreo  `POBLACIONAL` (Figura \@ref(fig:edaplot1)).

```{r edaplot1, echo=FALSE, out.width="80%", fig.cap= "Poblacional sample scheme"}
knitr::include_graphics("Fig/Fig1.png")
```


El caso del muestreo `COMERCIAL`, solo se registran los individuos que pase por la zaranda previo pesaje de la muestra (Figura \@ref(fig:edaplot2)).


```{r edaplot2, echo=FALSE, out.width="80%",fig.cap= "Comercial sample scheme"}
knitr::include_graphics("Fig/Fig2.png")
```

## Parámetros de HV

Uno de los principales elementos de información proviene de los estudios reproductivos y de parámetros realizados sobre coquina. A continuación un vistazo general a este importante componente para la evaluación de stock.

| Parámetro | Valor | Fuente  |
|:-------:|:------:|:-----------:|:---------:|
| vB Linf |  46.7 mm | [@Delgado2017] |
| vB k | 0.47 | [@Delgado2017] |
| M |  0.99 | [@Colakoglu2014] | 
| t0 | 0.29 | [@Colakoglu2014] |
| t0 | -0.59 | [@Delgado2017] |
| EDAD MÁXIMA |  EM= log(0.01)/M | Revisar | 
| Parámetros gravimetricos |  a;b |  Revisar | 
| L~50~ |   10.8mm | [@Delgado2018] |
| L~95~ |   Pendiente |  |


En cuanto a aspectos reproductivos, la coquina tiene los máximos de IGS entre los meses de Febrero – julio, con un máximo de desove entre mayo- julio, coincidiendo con la veda. La Figura \@ref(fig:matplot1) representa el ciclo vital interanual de coquina [@Delgado2017].


```{r matplot1, echo=FALSE, out.width="80%", fig.cap= "Schematic representation of the reproductive cycle, periods of emission of gametes and related recruitment events in populations of D. trunculus from SW Spain. Black symbols represent the C1 cohort (from February-March) and grey symbols represent the C2 cohort (from July)"}
knitr::include_graphics("Fig/Ciclo.png")
```

Por otro lado, cada componente y su rutina de estandarización estan detallas en los siguientes link;

- [Composiciones de Tallas](Compsiciones-de-Tallas.html)
- [Rendimiento Pesquero](Rendimiento-Pesquero.html)
- [Mapas](Mapas.html)
- [Indice de reclutamiento D15](Recruit_Index.html)

## Variables ambiental

Si bien los modelos de evaluación no suelen incorporar variables ambientales de manera directa a la modelación de la dinámica en cuestión, se pueden establecer correlaciones de las variables poblacionales obtenidas en el modelo y algún driver de comprobada influencia sobre los procesos poblacionales. En este sentido, analizaremos la información recabada durante los muestreos, es decir; Clorophila y variables fisicas como Temperatura, salinidad y ogeno disuelto.

- [Correlaciones ambientales](Correlaciones-variables-poblacionales-y-ambientales.html)

## Desembarques oficiales

Mediante canales oficiales, se solicitaron las cifras oficiales de desembarque de coquina en el Golfo de Cádiz para coquina. estos datos esn disponibpes desde el 2013. Si bien la pesqueria tiene sus inicios previo a este periodo, es vital contar con información de remoción por parte de la flota para posteriores ajustes de magnitudes en la estimación del modelo. 

A modo general, la serie historica de desembarques varia entre 1 y 15 t y estan repartidas entre distintas lonjas de comercialización. anualmente se puede ver en La Figura \@ref(fig:dese) representa el ciclo vital interanual de coquina [@Delgado2017].


```{r dese, echo=FALSE, fig.cap= "Desembarques oficiales para coquina en el Golfo de Cádiz entre los años 2013 y 2023"}
knitr::include_graphics("Fig/Desembarques.png")
```

El detalle de los datos y otras agrupaciones temporales y espaciales puede ser visto en el siguiente enlace;

- [Desembarques](Desembarques.html)

# Modelo de stock assessment

El modelo de la dinámica poblacional de coquina es implementado en Stock Synthesis (SS3)
(Versión 3.30.10) [@Methot2013]. SS3 es un modelo de evaluación
estructurado por edad con datos en talla de la clase de modelos denominada
*modelos de análisis integrados*. SS3 tiene un submodelo de población que simula
el crecimiento de una cohorte, desplazamiento, y procesos de mortalidad; un submodelo
de observación estima valores esperados para varios tipos de datos; un
submodelo estadístico caracteriza la bondad de ajuste de los datos y obtiene el
mejor ajuste de parámetros con varianza asociada; y un proceso de alimentación
para niveles necesarios para el manejo. SS produce las cantidades, con intervalos
de confianza, necesarias para implementar aversión al riesgo y reglas de control de
la pesca. El modelo está codificado en C++ con la estimación de parámetros
habilitada por diferenciación automática (ADMB) [@Fournier2012]. Las salidas
y análisis posteriores de visualización de los resultados son realizadas mediante la
librería *r4ss* [@Taylor2019]. SS3 está disponible en el laboratorio de
modelación numérica para poblaciones marinas explotadas de la National Oceanic
and Atmospheric Administration [NOAA](https://vlab.ncep.noaa.gov/web/stocksynthesis).

Los principales supuestos del modelo edad-estructurado con datos en talla de SS3 son:

- El stock de coquina está constituido por sub-unidades de stock que son parte
de un pool común (stock) dentro de la zona marisquera del Golfo de Cádiz.
- La mortalidad natural es conocida y constante entre años y edades.
- La mortalidad natural y por pesca son simultáneas (función de Baranov).
- El patrón de vulnerabilidad de los individuos es a la edad y sigue un modelo
logístico.
- El modelo supone que la almeja presenta en cada unidad de análisis un
stock cerrado y una población compuesta por no más de 5 grupos de
edades.
- El reclutamiento (segundo año de edad) es el resultado del “desove”
de conjunto de bancos vecinos y su sobrevivencia es modulada principalmente por cuestiones ambientales, lo que significa que los reclutamientos responden a procesos principalmente estocásticos donde la
función stock-recluta es difusa.

Este modelo y sus flujo de estimación se puede esquematizar como lo indica la  Figura \@ref(fig:ss3)

```{r ss3, echo=FALSE, out.width="80%", fig.cap= "Diagrama del flujo de datos, modelo y asesoría para coquina en el Golfo de Cádiz"}
knitr::include_graphics("Fig/Diagrama_Modelo.png")
```
# Consideraciones generales

- Este AED permite registrar rutinas y análisis reproducibles por cualquier investigador que requiera información complementarios respecto a la pesquería de coquina.

- Existe una gran diversidad de formatos y preguntas que estan de alguna manera representadas en las bases de datos aca utilizadas, lo cual dificulta su estandarización. Lo importante es realizar las preguntas correctas y precisas para poder, en primer lugar, manipular la data, y en segundo lugar, realizar los analisis correctos.

- El enfoque inicial de trabajo con las bases de datos fue el de repetir los análisis y rutinas que se habián estado realizando por el equipo FEMP-04, con el rigor necesario para obtener los mismos resultados, independiente se utilizarán diferentes algoritmos para calcular los principales indicadores poblacionales que se utilizan en la asesoría. Una ves logrado ello, la idea es hacer recomendaciones y observaciones que representen una mejora, simplificación y a su vez, una mejor representación de la dinámica poblacional de la pesquería de coquina en el Golfo de Cádiz.

- Por ultimo, el trabajo tiene como objetivo final extraer la información fidedigna de la dinámica poblacional de cada base de datos analizada para generar los templates adecuados y realizar una evaluación de stock que permita dar las bases cientificas para el Plan de Manejo de coquina. Este trabajo deevaluación se proyecta para el año 2024. 

- Este documento y sus codigos asociados tienen la intención de ser reporducibles y transparentes para futuras aplicaciones de asesoría científica en la pesquería de coquina en el Golfo de Cádiz.



```{r}


# Leer Datos completos

sizeall2 <- readRDS("~tallas13_24.RDS")


# Prepara data 

# filtro lo requerido por MD: Poblacional y Abril y Mayo
tallapobmar <- sizeall2 %>% 
  filter(rastro=="POBLACIONAL",
         MES %in% c("April","May"))

# Categorizar los datos
tallapobmar$CAT <- as.numeric(as.character(cut(
  x = tallapobmar$sizeE,
  breaks = seq(0, 50, 1),
  labels = seq(0, 49, 1),
  right = FALSE
)))


# Calcular la proporción de cada bin por año
tallaprop <- tallapobmar %>%
  group_by(ANO, MES, CATL) %>%
  summarise(count = n()) %>%
  mutate(proportion = count / sum(count) * 100) %>%
  arrange(ANO, MES,  CATL)


 # Grafico simple

ggplot(tallaprop,
       aes(x = CATL, 
           y = proportion, 
           fill = as.factor(ANO))) +
  geom_col() +
  facet_grid(ANO ~ MES) +
  labs(x = "CATL", y = "Proporción (%)", color = "Año") +
  theme_few() +
  geom_vline(xintercept = 10.8, col="red")+
  scale_fill_viridis_d(option = "H",
                       name="AÑO")+
  ggtitle("Proporción por Mes y Año")

# guardo data

saveRDS(tallaprop, "tallas_MD.RData")
write_csv(tallaprop, "tallas_MD.csv")


```




# Methodology

The object `ohbio2` come from data exploration analysis in data request
CCAMLR data. This objetc have bio information from krill.

```{r  echo=FALSE}
#datos entregados por secretaria de CCMLAR
metadata <- load("~/DOCAS/Data/565_C1_KRI_2021-10-01/DATA_PRODUCT_565.RData")
# Data procesada por MMardones
#ohbio <- load("DataLengthKrill.RData")
#ohbio
#metadata
#son lo mismo
#cargo objeto
meta <- get("METADATA")
c1 <- get("C1")
ohbio <- get("OBS_HAUL_BIOLOGY")
```

Join data set with master as `c1` set. This join is trought
`obs_haul_id` variable to get geoposition variables

```{r warning=FALSE}
ohbio2 <- left_join(c1, ohbio, by="obs_haul_id")
names(ohbio2)
```


```{r}
ohbio3 <- ohbio2 %>%
  mutate(Year = year(date_catchperiod_start),
         Month = month(date_catchperiod_start),
         Day = day(date_catchperiod_start)) %>% 
  #toupper() para convertir los valores a mayúsculas
  mutate(sex_code = toupper(sex_code)) %>% 
  dplyr::select(7, 9, 11, 12, 14, 24, 25, 29, 42, 44, 46, 47, 43, 45) |>  
  filter(asd_code=="481")
```


First thing is get different rater layer to join krill data length
according different porpoises.

```{r raster}
# Cargo linea de costa
coast <- load_Coastline()
coast1<- st_as_sf(coast) 
coast2 = st_transform(coast1, "+proj=latlong +ellps=WGS84")
# Uso las agrupaciones de Strata
strata <- st_read("~/DOCAS/Mapas/Antarctic_SHPfiles/Strata.shp",
                quiet=T)
strata=st_transform(strata, "+proj=latlong +ellps=WGS84")
```
Test Strata SSMU, just to know another way to join data, but this kind of spatial structuration is deprecated to mamagemente use (Figure\@ref(fig:maptest2).



Grouping bio data into stratas

```{r ssmu1}
ohbio6 <- st_as_sf(ohbio3 %>% 
                     drop_na(latitude_set_end), 
                   coords = c("longitude_set_end", "latitude_set_end"),  
                  crs = "+proj=latlong +ellps=WGS84")
```

## Study Area

```{r maptest, fig.cap="Strata Maps in 48.1"}
# y testeo el mapa
ssmap <- ggplot()+
  geom_sf(data = strata |> 
            filter(ID != "Outer") |>  
           mutate(ID = str_replace_all(ID, "Extra", "GS")),color="red")+
  geom_sf(data = ohbio6 |>
            drop_na(length_total_cm) |> 
            filter(Year>2017), 
          aes(color = length_total_cm)) +
  geom_text_repel(data = strata |>  
            filter(ID != "Outer") |>  
           mutate(ID = str_replace_all(ID, "Extra", "GS")), 
            aes(x = Labx, y = Laby, 
                label = ID), 
            min.segment.length = 0,
                             box.padding = 2,
                             max.overlaps = 10)+
  geom_sf(data = coast2, colour="black", fill=NA)+
  scale_color_viridis_c(option = "G",
                        name="Length (cm)")+
  ylim(230000, 2220000)+
  xlim(-3095349 , -1858911)+
  # coord_sf(crs = 32610)+ #sistema de prpyecccion para campos completos
  coord_sf(crs = 6932)+
  theme_bw()
ssmap
```


Length composition by Strata CCAMLR to visualization first. First step is group data into to poligons strata.

```{r eval=FALSE}
strata <- st_make_valid(strata)
sf4 <- st_join(strata, ohbio6)
# Save an object to a file
saveRDS(sf4, file = "sf4.rds")

```

Load RData
```{r}
# Restore the object
sf4 <- readRDS("sf4.rds")
```

Statistical difference

```{r}
m <- aov(length_total_cm ~ID, data=sf4)
plot(TukeyHSD(m))
```


## Data

histogram length data to viz in anthor way.


```{r warning=FALSE}
jzstrata <- ggplot(sf4 %>% 
                     mutate(ID = if_else(ID == "Extra", "GERLACHE", ID)) %>% 
               filter(Year>2010,
                      ID !="Outer"),
             aes(x=length_total_cm, 
                 y = as.factor(Month), 
                 fill=ID))+
  geom_density_ridges(stat = "binline", bins = 30, 
                      scale = 1.9, 
                      draw_baseline = FALSE,
                      alpha=0.9)+
  facet_grid(Year~ID) +   
  geom_vline(xintercept = 3.6, color = "red")+
  scale_x_continuous(breaks = seq(from = 1, to = 10, 
                                  by = 2))+
  scale_y_discrete(breaks = seq(from = 1, 
                                to = 12, by = 4))+
  scale_fill_viridis_d(name="Strata",
                       option="F")+
  theme_few()+
  xlab("Length (cm.)")+
  ylab("")
jzstrata
```
Now, must filter the DF

```{r}
sf5 <- sf4 |> 
  dplyr::select(c("ID",
        "date_catchperiod_start",
        "length_total_cm",
        "Year",
        "Month",
        "sex_code",
         "greenweight_kg")) |> 
  mutate(ID = if_else(ID == "Extra", "GERLACHE", ID)) |>  
  filter(ID !="Outer") |> 
  data.frame()
```



Calculating the proportion of records per year and per stratum in a table. This table allows us to establish criteria for defining the strata on which we will analyze krill parameter. We leave out just `JOIN`.


```{r}
# Calcular la proporción
proporcion <- (round(table(sf5$ID) / sum(table(sf5$ID))*100,2))

# Crear una tabla con las proporciones
tabla_proporcion <- as.data.frame(proporcion)
tabla_proporcion$Categoria <- rownames(tabla_proporcion)
rownames(tabla_proporcion) <- NULL

# Renombrar las columnas
colnames(tabla_proporcion) <- c("Strata", "%")

# Mostrar la tabla utilizando kbl()
kbl(tabla_proporcion, 
    caption = "Proportion length register by Strata")  |> 
  kable_classic(full_width = F, 
                html_font = "Cambria") |> 
  kable_styling(bootstrap_options = "striped", 
                latex_options = "striped")
```

## Parameters estimation `k` and `L_inf_`



```{r}
#MALE

sf5fil <- sf5 |>
  filter(ID %in% c("BS", "EI", "GERLACHE", "SSIW"),
         sex_code %in% "M") |>  
  mutate(date_catchperiod_start = as.Date(date_catchperiod_start)) |>  
  mutate(yearly_Group = floor_date(date_catchperiod_start, "year")) |>   # New column
  drop_na(length_total_cm) 

# Definir los nombres correspondientes a cada objeto lfq_results
nombres <- c("SSI", "BS", "GERLACHE", "EI")
# Crear una lista para almacenar los resultados de cada ID
lfq_results <- list()
# Iterar sobre cada ID
for (id in unique(sf5fil$ID)) {
  # Obtener el nombre correspondiente
  nombre <- nombres[which(unique(sf5fil$ID) == id)]
  # Filtrar los datos para el ID actual
  df_id <- sf5fil %>% filter(ID == id)
  # Crear un objeto lfq para el ID actual
  lfq <- lfqCreate(data = df_id,
                   Lname = "length_total_cm",
                   Dname = "yearly_Group",
                   bin_size = 0.1)
  # Agregar el resultado a la lista
  lfq_results[[id]] <- lfq
  # Graficar el objeto lfq
  plot(lfq, Fname = "catch",
       main = nombre)
}

#FEMALE

sf5filhe <- sf5 |>
  filter(ID %in% c("BS", "EI", "GERLACHE", "SSIW"),
         sex_code %in% "F") |>  
  mutate(date_catchperiod_start = as.Date(date_catchperiod_start)) |>  
  mutate(yearly_Group = floor_date(date_catchperiod_start, "year")) |>   # New column
  drop_na(length_total_cm) 

# Definir los nombres correspondientes a cada objeto lfq_results
nombres <- c("SSI", "BS", "GERLACHE", "EI")
# Crear una lista para almacenar los resultados de cada ID
lfq_resultshe <- list()
# Iterar sobre cada ID
for (id in unique(sf5filhe$ID)) {
  # Obtener el nombre correspondiente
  nombre <- nombres[which(unique(sf5filhe$ID) == id)]
  # Filtrar los datos para el ID actual
  df_idhe <- sf5filhe %>% filter(ID == id)
  # Crear un objeto lfq para el ID actual
  lfqhe <- lfqCreate(data = df_idhe,
                   Lname = "length_total_cm",
                   Dname = "yearly_Group",
                   bin_size = 0.1)
  # Agregar el resultado a la lista
  lfq_resultshe[[id]] <- lfqhe
  # Graficar el objeto lfq
  plot(lfqhe, Fname = "catch",
       main = nombre)
}
```

Identified difference in length distribution just to male:

```{r message=FALSE}
Bhattacharya(lfq_results$EI)
```


```{r message=FALSE}
Bhattacharya(lfq_results$SSIW)
```


```{r message=FALSE}
Bhattacharya(lfq_results$BS)
```


```{r message=FALSE}
Bhattacharya(lfq_results$GERLACHE)
```

now we assign objet to male `lfq_result` and female `lfq_resulthe` and plot with `lfqRestructure()`


Male

```{r}
# Definir los nombres correspondientes a cada objeto lfq_results
nombres <- c("SSI", "BS", "GERLACHE", "EI")
# Iterar sobre cada objeto lfq almacenado en lfq_results
for (i in seq_along(lfq_results)) {
  lfq <- lfq_results[[i]]
  # Obtener el nombre correspondiente
  nombre <- nombres[i]
  # Restructurar el objeto lfq
  lfqbin <- lfqRestructure(lfq, MA = 3, addl.sqrt = TRUE)
  # Graficar el objeto lfq reestructurado
  plot(lfqbin, hist.col = c("white", "black"),
       image.col = c(rep(rgb(1,0.8,0.8),1000), "white", 
                     rep(rgb(0.8,0.8,1),1000)),
       ylim = c(0,max(lfqbin$midLengths+0.5)),
       main = nombre)
  # Ajustar curvas al objeto lfq reestructurado
  tmp <- lfqFitCurves(lfqbin, par = list(Linf=6.5, 
                                          K=0.45,
                                          t_anchor=0.5),
                      draw = TRUE, col=4, lty=2)
}
```

Female

```{r}
# Crear una lista para almacenar los resultados de PW_results <- list()

# Definir los nombres correspondientes a cada objeto lfq_results
nombres <- c("SSI", "BS", "GERLACHE", "EI")

# Iterar sobre cada objeto lfq almacenado en lfq_results
for (i in seq_along(lfq_resultshe)) {
  lfqhe <- lfq_resultshe[[i]]
  
  # Obtener el nombre correspondiente
  nombre <- nombres[i]
  
  # Restructurar el objeto lfq
  lfqbinhe <- lfqRestructure(lfqhe, MA = 3, addl.sqrt = TRUE)
  
  # Graficar el objeto lfq reestructurado
  plot(lfqbinhe, hist.col = c("white", "black"),
       image.col = c(rep(rgb(1,0.8,0.8),1000), "white", 
                     rep(rgb(0.8,0.8,1),1000)),
       ylim = c(0,max(lfqbinhe$midLengths+0.5)),
       main = nombre)
  
  # Ajustar curvas al objeto lfq reestructurado
  tmp <- lfqFitCurves(lfqbinhe, par = list(Linf=6.5, 
                                          K=0.45,
                                          t_anchor=0.5),
                      draw = TRUE, col=4, lty=2)
}

```
### Modal Progression analysis with `ELEFAN` to estimated `Linf`and `K`

Method based on @Pauly1987 and @Mildenberger2017

#### Krill Male

first we use `mixR` to identified numbers of compoenent (modal compositions) we have each stratum. With this result, set `ELEFAN` method


```{r eval=FALSE}
unique_ids <- unique(sf5$ID)

obj_id <- list()

for (id in unique_ids) {
  filtered_data <- sf5 %>% 
    drop_na(length_total_cm) %>% 
    filter(sex_code %in% "M", 
           ID !="JOIN",
           ID == id)
  obj_id[[id]] <- filtered_data
}

# select number of components

s_normalgs = select(obj_id$GERLACHE$length_total_cm, ncomp = 2:6)
plot(s_normalgs)
s_normalei = select(obj_id$EI$length_total_cm, ncomp = 2:6)
plot(s_normalei)
s_normalbs = select(obj_id$BS$length_total_cm, ncomp = 2:6)
plot(s_normalbs)
s_normalsswi = select(obj_id$SSWI$length_total_cm, ncomp = 2:6)
plot(s_normalsswi)

# fit a Normal mixture model
modgs = mixfit(obj_id$GERLACHE$length_total_cm, ncomp = 3,
              pi = c(0.5, 0.5, 0.5), 
              mu = c( 3, 4, 5), 
              sd = c(0.2, 0.2, 0.2))


# fit a Normal mixture model
modei = mixfit(obj_id$EI$length_total_cm, ncomp = 4,
              pi = c(0.5, 0.5, 0.5, 0.5), 
              mu = c( 3, 4, 5, 6), 
              sd = c(0.2, 0.2, 0.2, 0.2))


# fit a Normal mixture model
modbs = mixfit(obj_id$BS$length_total_cm, ncomp = 5,
              pi = c(0.5, 0.5, 0.5, 0.5, 0.5), 
              mu = c( 2, 3, 4, 5, 6), 
              sd = c(0.2, 0.2, 0.2, 0.2, 0.2))


# fit a Normal mixture model
modsswi = mixfit(obj_id$SSIW$length_total_cm, ncomp = 4,
              pi = c(0.5, 0.5, 0.5, 0.5), 
              mu = c( 3, 4, 5, 6), 
              sd = c(0.2, 0.2, 0.2, 0.2))
```


```{r, eval=FALSE, fig.width=8, fig.height=5}
GSplot <- plot(modgs,
     theme = "bw",
     title ="GERLACHE")
EIplot <- plot(modei,
     theme = "bw",
     title ="ELEPHANT ISLAND")
BSplot <- plot(modbs,
     theme = "bw",
     title ="BRANSFIELD STRAIT")
SSWIplot <- plot(modsswi,
     theme = "bw",
     title ="SSWI")

ggarrange(GSplot, 
          EIplot, 
          BSplot, 
          SSWIplot, 
          common.legend = TRUE,
          ncol=4,
          legend="right")
```


```{r}
#### Parameters to `SSWI`

# run ELEFAN with simulated annealing
res_SAsswi <- ELEFAN_SA(lfq_results$SSIW, 
                    SA_time = 60*0.5, 
                    MA = 5, 
                    agemax = 5,
                    seasonalised = TRUE, addl.sqrt = TRUE,
                    init_par = list(Linf = 6, 
                                    K = 0.5, 
                                    t_anchor = 0.5,
                                    C=0.5, 
                                    ts = 0.5),
                    low_par = list(Linf = 5,
                                   K = 0.01,
                                   t_anchor = 0, 
                                   C = 0, 
                                   ts = 0),
                    up_par = list(Linf = 7.5,
                                  K = 1, 
                                  t_anchor = 1,
                                  C = 1, ts = 1))

# run ELEFAN with genetic algorithm
res_GAsswi <- ELEFAN_GA(lfq_results$SSIW, 
                    MA = 5, 
                    seasonalised = TRUE, 
                    maxiter = 10, 
                    agemax = 5,
                    addl.sqrt = TRUE,
                     low_par = list(Linf = 5,
                                   K = 0.5,
                                   t_anchor = 0, 
                                   C = 0, 
                                   ts = 0),
                    up_par = list(Linf = 7.5,
                                  K = 1, 
                                  t_anchor = 1,
                                  C = 1, ts = 1),
                    monitor = FALSE)

#### Parameters to `EI`

# run ELEFAN with simulated annealing
res_SAei <- ELEFAN_SA(lfq_results$EI, 
                    SA_time = 60*0.5, 
                    MA = 5, 
                    agemax = 5,
                    seasonalised = TRUE, addl.sqrt = TRUE,
                    init_par = list(Linf = 6, 
                                    K = 0.5, 
                                    t_anchor = 0.5,
                                    C=0.5, 
                                    ts = 0.5),
                    low_par = list(Linf = 5,
                                   K = 0.01,
                                   t_anchor = 0, 
                                   C = 0, 
                                   ts = 0),
                    up_par = list(Linf = 7.5,
                                  K = 1, 
                                  t_anchor = 1,
                                  C = 1, ts = 1))

# run ELEFAN with genetic algorithm
res_GAei <- ELEFAN_GA(lfq_results$EI, 
                    MA = 5, 
                    seasonalised = TRUE, 
                    maxiter = 10, 
                    agemax = 5,
                    addl.sqrt = TRUE,
                     low_par = list(Linf = 5,
                                   K = 0.5,
                                   t_anchor = 0, 
                                   C = 0, 
                                   ts = 0),
                    up_par = list(Linf = 7.5,
                                  K = 1, 
                                  t_anchor = 1,
                                  C = 1, ts = 1),
                    monitor = FALSE)


#### Parameters to `BS`

# run ELEFAN with simulated annealing
res_SAbs <- ELEFAN_SA(lfq_results$BS, 
                    SA_time = 60*0.5, 
                    MA = 5, 
                    agemax = 5,
                    seasonalised = TRUE, addl.sqrt = TRUE,
                   init_par = list(Linf = 6, 
                                    K = 0.5, 
                                    t_anchor = 0.5,
                                    C=0.5, 
                                    ts = 0.5),
                    low_par = list(Linf = 5,
                                   K = 0.01,
                                   t_anchor = 0, 
                                   C = 0, 
                                   ts = 0),
                    up_par = list(Linf = 7.5,
                                  K = 1, 
                                  t_anchor = 1,
                                  C = 1, ts = 1))

# run ELEFAN with genetic algorithm
res_GAbs <- ELEFAN_GA(lfq_results$BS, 
                    MA = 5, 
                    seasonalised = TRUE, 
                    maxiter = 10, 
                    agemax = 5,
                    addl.sqrt = TRUE,
                    low_par = list(Linf = 5,
                                   K = 0.01,
                                   t_anchor = 0, 
                                   C = 0, 
                                   ts = 0),
                    up_par = list(Linf = 7.5,
                                  K = 1, 
                                  t_anchor = 1,
                                  C = 1, ts = 1),
                    monitor = FALSE)


#### Parameters to `GERLACHE`

# run ELEFAN with simulated annealing
res_SAgs <- ELEFAN_SA(lfq_results$GERLACHE, 
                    SA_time = 60*0.5, 
                    MA = 5, 
                    agemax = 5,
                    seasonalised = TRUE, addl.sqrt = TRUE,
                    init_par = list(Linf = 6, 
                                    K = 0.5, 
                                    t_anchor = 0.5,
                                    C=0.5, 
                                    ts = 0.5),
                    low_par = list(Linf = 5,
                                   K = 0.01,
                                   t_anchor = 0, 
                                   C = 0, 
                                   ts = 0),
                    up_par = list(Linf = 7.5,
                                  K = 1, 
                                  t_anchor = 1,
                                  C = 1, ts = 1))

# run ELEFAN with genetic algorithm
res_GAgs <- ELEFAN_GA(lfq_results$GERLACHE, 
                    MA = 5, 
                    seasonalised = TRUE, 
                    maxiter = 10, 
                    agemax = 5,
                    addl.sqrt = TRUE,
                    low_par = list(Linf = 5,
                                   K = 0.01,
                                   t_anchor = 0, 
                                   C = 0, 
                                   ts = 0),
                    up_par = list(Linf = 7.5,
                                  K = 1, 
                                  t_anchor = 1,
                                  C = 1, ts = 1),
                    monitor = FALSE)
```
#### Krill Female


```{r}
#### Parameters to `SSWI`

# run ELEFAN with simulated annealing
res_SAsswihe <- ELEFAN_SA(lfq_resultshe$SSIW, 
                    SA_time = 60*0.5, 
                    MA = 5, 
                    agemax = 5,
                    seasonalised = TRUE, addl.sqrt = TRUE,
                    init_par = list(Linf = 6, 
                                    K = 0.5, 
                                    t_anchor = 0.5,
                                    C=0.5, 
                                    ts = 0.5),
                    low_par = list(Linf = 5,
                                   K = 0.01,
                                   t_anchor = 0, 
                                   C = 0, 
                                   ts = 0),
                    up_par = list(Linf = 7.5,
                                  K = 1, 
                                  t_anchor = 1,
                                  C = 1, ts = 1))

# run ELEFAN with genetic algorithm
res_GAsswihe <- ELEFAN_GA(lfq_resultshe$SSIW, 
                    MA = 5, 
                    seasonalised = TRUE, 
                    maxiter = 10, 
                    agemax = 5,
                    addl.sqrt = TRUE,
                     low_par = list(Linf = 5,
                                   K = 0.01,
                                   t_anchor = 0, 
                                   C = 0, 
                                   ts = 0),
                    up_par = list(Linf = 7.5,
                                  K = 1, 
                                  t_anchor = 1,
                                  C = 1, ts = 1),
                    monitor = FALSE)


#### Parameters to `EI`

# run ELEFAN with simulated annealing
res_SAeihe <- ELEFAN_SA(lfq_resultshe$EI, 
                    SA_time = 60*0.5, 
                    MA = 5, 
                    agemax = 5,
                    seasonalised = TRUE, addl.sqrt = TRUE,
                    init_par = list(Linf = 6, 
                                    K = 0.5, 
                                    t_anchor = 0.5,
                                    C=0.5, 
                                    ts = 0.5),
                    low_par = list(Linf = 5,
                                   K = 0.01,
                                   t_anchor = 0, 
                                   C = 0, 
                                   ts = 0),
                    up_par = list(Linf = 7.5,
                                  K = 1, 
                                  t_anchor = 1,
                                  C = 1, ts = 1))

# run ELEFAN with genetic algorithm
res_GAeihe <- ELEFAN_GA(lfq_resultshe$EI, 
                    MA = 5, 
                    seasonalised = TRUE, 
                    maxiter = 10, 
                    agemax = 5,
                    addl.sqrt = TRUE,
                     low_par = list(Linf = 5,
                                   K = 0.01,
                                   t_anchor = 0, 
                                   C = 0, 
                                   ts = 0),
                    up_par = list(Linf = 7.5,
                                  K = 1, 
                                  t_anchor = 1,
                                  C = 1, ts = 1),
                    monitor = FALSE)


#### Parameters to `BS`


# run ELEFAN with simulated annealing
res_SAbshe <- ELEFAN_SA(lfq_resultshe$BS, 
                    SA_time = 60*0.5, 
                    MA = 5, 
                    agemax = 5,
                    seasonalised = TRUE, addl.sqrt = TRUE,
                   init_par = list(Linf = 6, 
                                    K = 0.5, 
                                    t_anchor = 0.5,
                                    C=0.5, 
                                    ts = 0.5),
                    low_par = list(Linf = 5,
                                   K = 0.01,
                                   t_anchor = 0, 
                                   C = 0, 
                                   ts = 0),
                    up_par = list(Linf = 7.5,
                                  K = 1, 
                                  t_anchor = 1,
                                  C = 1, ts = 1))

# run ELEFAN with genetic algorithm
res_GAbshe <- ELEFAN_GA(lfq_resultshe$BS, 
                    MA = 5, 
                    seasonalised = TRUE, 
                    maxiter = 10, 
                    agemax = 5,
                    addl.sqrt = TRUE,
                    low_par = list(Linf = 5,
                                   K = 0.01,
                                   t_anchor = 0, 
                                   C = 0, 
                                   ts = 0),
                    up_par = list(Linf = 7.5,
                                  K = 1, 
                                  t_anchor = 1,
                                  C = 1, ts = 1),
                    monitor = FALSE)


#### Parameters to `GERLACHE`


# run ELEFAN with simulated annealing
res_SAgshe <- ELEFAN_SA(lfq_resultshe$GERLACHE, 
                    SA_time = 60*0.5, 
                    MA = 5, 
                    agemax = 5,
                    seasonalised = TRUE, addl.sqrt = TRUE,
                    init_par = list(Linf = 6, 
                                    K = 0.5, 
                                    t_anchor = 0.5,
                                    C=0.5, 
                                    ts = 0.5),
                    low_par = list(Linf = 5,
                                   K = 0.01,
                                   t_anchor = 0, 
                                   C = 0, 
                                   ts = 0),
                    up_par = list(Linf = 7.5,
                                  K = 1, 
                                  t_anchor = 1,
                                  C = 1, ts = 1))

# run ELEFAN with genetic algorithm
res_GAgshe <- ELEFAN_GA(lfq_resultshe$GERLACHE, 
                    MA = 5, 
                    seasonalised = TRUE, 
                    maxiter = 10, 
                    agemax = 5,
                    addl.sqrt = TRUE,
                    low_par = list(Linf = 5,
                                   K = 0.01,
                                   t_anchor = 0, 
                                   C = 0, 
                                   ts = 0),
                    up_par = list(Linf = 7.5,
                                  K = 1, 
                                  t_anchor = 1,
                                  C = 1, ts = 1),
                    monitor = FALSE)
```

Resuming parameters to both sex  by strata to krill
```{r}
#male
GAbs <- unlist(res_GAbs$par)
SAbs <- unlist(res_SAbs$par)
GAei <- unlist(res_GAei$par)
SAei <- unlist(res_SAei$par)
GAsswi <- unlist(res_GAsswi$par)
SAsswi <- unlist(res_SAsswi$par)
GAgs <- unlist(res_GAgs$par)
SAgs <- unlist(res_SAgs$par)
#female
GAbshe <- unlist(res_GAbshe$par)
SAbshe <- unlist(res_SAbshe$par)
GAeihe <- unlist(res_GAeihe$par)
SAeihe <- unlist(res_SAeihe$par)
GAsswihe <- unlist(res_GAsswihe$par)
SAsswihe <- unlist(res_SAsswihe$par)
GAgshe <- unlist(res_GAgshe$par)
SAgshe <- unlist(res_SAgshe$par)
# join 
t_k_linf_m <- rbind(GAbs[1:2],
                  SAbs[1:2],
                  GAei[1:2],
                  SAei[1:2],
                  GAsswi[1:2],
                  SAsswi[1:2],
                  GAgs[1:2],
                  SAgs[1:2])
t_k_linf_f <- rbind(GAbshe[1:2],
                  SAbshe[1:2],
                  GAeihe[1:2],
                  SAeihe[1:2],
                  GAsswihe[1:2],
                  SAsswihe[1:2],
                  GAgshe[1:2],
                  SAgshe[1:2])
row_names <- c("GA BS", "SA BS", "GA EI", 
                 "SA EI", "GA SSWI", "SA SSWI",
                 "GA GS", "SA GS")
rownames(t_k_linf_m) <- row_names
rownames(t_k_linf_f) <- row_names
col_names_m <- c("L inf Male", "K Male")
col_names_f <- c("L inf Female", "K Female")
colnames(t_k_linf_m) <- col_names_m
colnames(t_k_linf_f) <- col_names_f


total_para <- round(cbind(t_k_linf_f,
                    t_k_linf_m),3)
t_k_linf_total <- as_tibble(total_para, rownames = "group")


means <- t_k_linf_total %>%
  summarise(across(where(is.numeric), ~ mean(.x, na.rm = TRUE))) %>%
  mutate(group = "Mean")

t_k_linf <- bind_rows(t_k_linf_total, means)
```

```{r eval=FALSE}
write_csv(t_k_linf, "parametros_krill.csv")
```


total Table with `L_inf_` and `K`

```{r}
t_k_linf %>%
  separate(group, into = c("METHOD", "STRATA"), sep = " ") %>% 
  kbl(booktabs = T,
      position="ht!",
    caption = "Parametres LH in different strata with 2 algoritms to estimation") %>%
  kable_styling(latex_options = c("striped",
                                  "condensed"),
                full_width = FALSE)

```

Made VB curves by methot and strata by male

separated group


```{r}
t_k_linf_sep <- t_k_linf %>% 
  filter(group != "Mean") %>% 
   separate(group, into = c("METHOD", "STRATA"), sep = " ")
```


```{r}
# Definir la función de Von Bertalanffy
von_bertalanffy <- function(t, L_inf, K) {
  L_inf * (1 - exp(-K * (t-t0)))
}

# Generar una secuencia de tiempos (por ejemplo, de 0 a 5 años)
t0 <- -0.3
time <- seq(0, 7, by = 0.1)

# Calcular longitud esperada para cada zona y tiempo
df_curves_male <- t_k_linf_sep %>%
  dplyr::select(c(1:2, 5:6)) %>% 
  rowwise() %>%
  mutate(length = list(von_bertalanffy(time, `L inf Male`, `K Male`))) %>%
  unnest(length)
# Agregar el vector de tiempo al DataFrame df_curves
df_curves_male$time <- rep(time, nrow(t_k_linf_sep))
# Graficar con ggplot
male <- ggplot(df_curves_male,
               aes(x = time, 
                              y = length,
                              group=STRATA,
                              colour=STRATA)) +
  geom_line(linewidth=1.1) +
  labs(title = "Male",
       x = "years",
       y = "Length (cm)") +
  theme_few()+
  facet_wrap(.~METHOD)+
  scale_colour_viridis_d(option="F",
                         name="Strata")

```
Made VB curves by methot and strata by female

```{r}
# Calcular longitud esperada para cada zona y tiempo
df_curves_female <- t_k_linf_sep %>%
  dplyr::select(c(1:4)) %>% 
  rowwise() %>%
  mutate(length = list(von_bertalanffy(time, `L inf Female`, `K Female`))) %>%
  unnest(length)
# Agregar el vector de tiempo al DataFrame df_curves
df_curves_female$time <- rep(time, nrow(t_k_linf_sep))
# Graficar con ggplot
female <- ggplot(df_curves_female,
               aes(x = time, 
                              y = length,
                              group=STRATA,
                              colour=STRATA)) +
  geom_line(linewidth=1.1) +
  labs(title = "Female",
       x = "years",
       y = "Length (cm)") +
  theme_few()+
  facet_wrap(.~METHOD)+
  scale_colour_viridis_d(option="F",
                         name="Strata")

```

both plot

```{r fig.width=10, fig.height=8}
ggarrange(female, male, common.legend = TRUE,
          ncol=1,
          legend="bottom")
```


### Method Nonlinear Mixed-Effects Models

Fit a nonlinear mixed-effects model (NLMM) to data, via maximum likelihood using `lme4` (@Bates2015) to calcularte parametrs

(work in progress)

```{r eval=FALSE, echo=TRUE}

#We use firts a descomposition methot with library `mixR` and the

sf52020 <- sf5 %>% 
  filter(sex_code %in% "F",
         ID == "EI",
         Year =="2020") %>% 
  drop_na(length_total_cm)

# fit a Normal mixture model
mod1 = mixfit(sf52020$length_total_cm, ncomp = 4,
              pi = c(0.5, 0.5, 0.5, 0.5), 
              mu = c( 3, 4, 5, 6), 
              sd = c(0.2, 0.2, 0.2, 0.2))
mod2_weibull = mixfit(sf6$length_total_cm, family = 'weibull', ncomp = 3)

s_weibull = select(sf5a$length_total_cm, ncomp = 2:6, family = 'weibull')

s_normal = select(sf5a$length_total_cm, ncomp = 2:6)
plot(s_weibull)
plot(s_normal)

# plot the fitted model# plot the fitted model# plot the fitted model
plot(mod1)
plot(mod2_weibull)

# fit a Normal mixture model (equal variance)
mod1_ev = mixfit(sf6$length_total_cm, ncomp = 2, ev = TRUE)

```

## Natural Mortality in Krill

In this exercises different bioanalogic methods are tested with General Algoritm

#### MALE

```{r}
MSSWI <- c(res_GAsswi$par, list(agemax = res_GAsswi$agemax))
# use the function M_empirical to estimate natural mortality
Msswi <- M_empirical(Linf = MSSWI$Linf, K_l = MSSWI$K, 
                  tmax = MSSWI$agemax, temp = 5,
                  tm50 = 2,
                  method = c("Pauly_Linf", "Hoenig", 
                            "Hoenig",
                             "AlversonCarney",
                             "RikhterEfanov"
                             ))
# Bransfield
BS <- c(res_GAbs$par, list(agemax = res_GAbs$agemax))

# use the function M_empirical to estimate natural mortality
Mbs <- M_empirical(Linf = BS$Linf, K_l = BS$K, 
                  tmax = BS$agemax, temp = 5,
                  tm50 = 2,
                  method = c("Pauly_Linf", "Hoenig", 
                              "Hoenig",
                             "AlversonCarney",
                             "RikhterEfanov"
                             ))
# GERLACHE
GS <- c(res_GAgs$par, list(agemax = res_GAgs$agemax))

# use the function M_empirical to estimate natural mortality
Mgs <- M_empirical(Linf = GS$Linf, K_l = GS$K, 
                  tmax = GS$agemax, temp = 5,
                   tm50 = 2,
                  method = c("Pauly_Linf", "Hoenig", 
                             "Hoenig",
                             "AlversonCarney",
                             "RikhterEfanov"
                             ))
# Elephand Island
MEI <- c(res_GAei$par, list(agemax = res_GAei$agemax))

# use the function M_empirical to estimate natural mortality
Mei <- M_empirical(Linf = MEI$Linf, K_l = MEI$K, 
                  tmax = MEI$agemax, temp = 5,
                  tm50 = 2,
                  method = c("Pauly_Linf", "Hoenig", 
                             "Hoenig",
                             "AlversonCarney",
                             "RikhterEfanov"
                             ))
```

#### FEMALE

```{r}
MSSWIhe <- c(res_GAsswihe$par, list(agemax = res_GAsswihe$agemax))
# use the function M_empirical to estimate natural mortality
Msswihe <- M_empirical(Linf = MSSWIhe$Linf, K_l = MSSWIhe$K, 
                  tmax = MSSWIhe$agemax, temp = 5,
                  tm50 = 2,
                  method = c("Pauly_Linf", 
                            "Hoenig",
                             "AlversonCarney",
                             "RikhterEfanov"
                             ))
# Bransfield
BShe <- c(res_GAbshe$par, list(agemax = res_GAbshe$agemax))

# use the function M_empirical to estimate natural mortality
Mbshe <- M_empirical(Linf = BShe$Linf, K_l = BShe$K, 
                  tmax = BShe$agemax, temp = 5,
                  tm50 = 2,
                  method = c("Pauly_Linf", 
                              "Hoenig",
                             "AlversonCarney",
                             "RikhterEfanov"
                             ))
# GERLACHE
GShe <- c(res_GAgshe$par, list(agemax = res_GAgshe$agemax))

# use the function M_empirical to estimate natural mortality
Mgshe <- M_empirical(Linf = GShe$Linf, K_l = GShe$K, 
                  tmax = GShe$agemax, temp = 5,
                   tm50 = 2,
                  method = c("Pauly_Linf", 
                             "Hoenig",
                             "AlversonCarney",
                             "RikhterEfanov"
                             ))
# Elephand Island
MEIhe <- c(res_GAeihe$par, list(agemax = res_GAeihe$agemax))

# use the function M_empirical to estimate natural mortality
Meihe <- M_empirical(Linf = MEIhe$Linf, K_l = MEIhe$K, 
                  tmax = MEIhe$agemax, temp = 5,
                  tm50 = 2,
                  method = c("Pauly_Linf", 
                             "Hoenig",
                             "AlversonCarney",
                             "RikhterEfanov"
                             ))
```

```{r}
# junto las bases

Total_M_male <- cbind(Mei, Mbs, Mgs, Msswi)
colnames(Total_M_male) <- c("EI", "BS" , "GS", "SSWI")
mean_m <- colMeans(Total_M_male, na.rm = TRUE)
Total_M_Mean_male <- rbind(Total_M_male, Mean = mean_m)
# Agregar los promedios como una nueva fila al final del array

Total_M_femal <- cbind(Meihe, Mbshe, Mgshe, Msswihe)
colnames(Total_M_femal) <- c("EI", "BS" , "GS", "SSWI")
mean_m <- colMeans(Total_M_femal, na.rm = TRUE)
Total_M_Mean_femal <- rbind(Total_M_femal, Mean = mean_m)
```


```{r}
Total_M_Mean_male  %>%
  kbl(booktabs = T,
      position="ht!",
    caption = "Estimated M by Strata for Male") %>%
  kable_styling(latex_options = c("striped",
                                  "condensed"),
                full_width = FALSE)

Total_M_Mean_femal  %>%
  kbl(booktabs = T,
      position="ht!",
    caption = "Estimated M by Strata for Female") %>%
  kable_styling(latex_options = c("striped",
                                  "condensed"),
                full_width = FALSE)

```


Plot to female
```{r}
# Convertir la matriz a data.frame
df_female <- as.data.frame(Total_M_Mean_femal)

# Agregar la columna de métodos
df_female$Method <- rownames(Total_M_Mean_femal)

# Convertir el data.frame a formato largo
df_long <- df_female %>%
  pivot_longer(cols = EI:SSWI, 
               names_to = "Stratum", 
               values_to = "Value")

# Dot Plot
m_female<- ggplot(df_long %>%
                              drop_na() %>%
                              filter(Method != "Mean"), 
                            aes(x = Stratum, 
                                y = Value,
                                fill = Method)) +
    geom_point(size = 3,     
              shape = 21,   
              color = "black") + 
  geom_text_repel(aes(label = round(Value, 3)),  
                  size = 3,                      
                  box.padding = 0.35,            
                  point.padding = 0.5,         
                  segment.color = 'grey50',
                  min.segment.length = 0, 
                  nudge_y = 0.05,   
                  direction = "both") +
  labs(title = "Female",
       x = "",
       y = "Natural Mortality",
       fill = "Method") +
  theme_few() +
  scale_fill_viridis_d(option = "H") +
  ylim(0, 2)
```

Plot to male
```{r}
# Convertir la matriz a data.frame
df_male <- as.data.frame(Total_M_Mean_male)

# Agregar la columna de métodos
df_male$Method <- rownames(Total_M_Mean_male)

# Convertir el data.frame a formato largo
df_long_male <- df_male %>%
  pivot_longer(cols = EI:SSWI, 
               names_to = "Stratum", 
               values_to = "Value") 

# Dot Plot
m_male<- ggplot(df_long_male %>%
                              drop_na() %>%
                              filter(Method != "Mean"), 
                            aes(x = Stratum, 
                                y = Value,
                                fill = Method)) +
  geom_point(size = 3,     
              shape = 21,   
              color = "black") +  
  geom_text_repel(aes(label = round(Value, 3)),  
                  size = 3,                      
                  box.padding = 0.35,            
                  point.padding = 0.5,         
                  segment.color = 'grey50',
                  min.segment.length = 0, 
                  nudge_y = 0.05,   
                  direction = "both") +
  labs(title = "Male",
       x = "",
       y = "Natural Mortality",
       fill = "Method") +
  theme_few() +
  scale_fill_viridis_d(option = "H") +
  ylim(0, 2)

```

both plot

```{r}
ggarrange(m_female, m_male, 
          common.legend = TRUE,
          ncol=1,
          legend="right")
```
Statistical diferences in female

```{r}
# Realizar la prueba ANOVA
anova_result <- aov(Value ~ Stratum, data = df_long_male %>% drop_na())
summary(anova_result)
# Realizar la prueba post hoc de Tukey
tukey_result <- TukeyHSD(anova_result)
# Convertir los resultados de Tukey a un data frame
tukey_df <- as.data.frame(tukey_result$Stratum)
tukey_df$pair <- rownames(tukey_df)
tukey_df <- tukey_df %>%
  mutate(Stratum1 = sapply(strsplit(pair, "-"), `[`, 1),
         Stratum2 = sapply(strsplit(pair, "-"), `[`, 2))

# Seleccionar las columnas relevantes
tukey_table <- tukey_df %>%
  dplyr::select(Stratum1, Stratum2, diff, `p adj`, `lwr`, `upr`) %>%
  rename(Difference = diff, 
         P_value = `p adj`, 
         Lower_CI = `lwr`, 
         Upper_CI = `upr`)


kbl(tukey_table, 
    caption = "Test to differences between strata")  |> 
  kable_classic(full_width = F, 
                html_font = "Cambria") |> 
  kable_styling(bootstrap_options = "striped", 
                latex_options = "striped")



```
Statistical diferences in female

```{r}
# Realizar la prueba ANOVA
anova_result_ma <- aov(Value ~ Stratum, data = df_long %>% drop_na())
summary(anova_result_ma)
# Realizar la prueba post hoc de Tukey
tukey_result_ma <- TukeyHSD(anova_result_ma)
# Convertir los resultados de Tukey a un data frame
tukey_df_ma <- as.data.frame(tukey_result_ma$Stratum)
tukey_df_ma$pair <- rownames(tukey_df_ma)
tukey_df_ma <- tukey_df_ma %>%
  mutate(Stratum1 = sapply(strsplit(pair, "-"), `[`, 1),
         Stratum2 = sapply(strsplit(pair, "-"), `[`, 2))

# Seleccionar las columnas relevantes
tukey_table_ma <- tukey_df_ma %>%
  dplyr::select(Stratum1, Stratum2, diff, `p adj`, `lwr`, `upr`) %>%
  rename(Difference = diff, 
         P_value = `p adj`, 
         Lower_CI = `lwr`, 
         Upper_CI = `upr`)


kbl(tukey_table, 
    caption = "Test to differences between strata")  |> 
  kable_classic(full_width = F, 
                html_font = "Cambria") |> 
  kable_styling(bootstrap_options = "striped", 
                latex_options = "striped")


```


# References



